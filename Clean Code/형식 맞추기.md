## 코드 형식은 의사소통의 일환이다.

> 형식이 맞춰진 코드라면 독자들의 기대감을 충족시킨다.


### 적절한 행 길이
일반적으로 파일 크기는 클래스의 크기이다.  
시스템(서비스)의 규모가 크다는 게 한 파일의 길이가 길어도 됨을 허락하진 않는다.  
행 길이가 적은 파일(클래스)가 일반적으로 이해하기 쉽다.

### 신문 기사처럼 작성하라
- 위에서 아래로 읽는다.
- 소스 파일의 윗부분은 고차원 개념이 들어가야한다.
- 아래로 갈수록 의도를 세세하게 묘사하며 저차원 수준으로 들어간다.
- 신문 기사에서 표제를 보고 내용을 추측하며 읽을지 결정하듯, 우리의 코드도 그래야 한다.

### 개념은 빈 행으로 분리하라
- 빈 행을 알맞게 독자를 생각하며 넣어야 한다.
- 일반적으로 패키지 선언부, import 문, 함수 사이 정도이다.
- 일련의 행 묶음이 완결된 생각 하나를 표현한다.

### 수직 거리
- 밀접한 두 개념은 세로 거리로 연관성을 표현한다.
  - ex) `fun a()` 와 `fun a(number: Int)` 가 있다면 두 함수는 같이(위, 아래) 존재해야 한다.
- **변수**는 사용하는 위치에 최대한 가까이 선언한다.
- **인스턴스 변수**는 클래스 맨 처음에 두며, 변수 간에 세로로 거리를 두지 않는다.(Java 기준)
- **종속 함수** : 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이에 배치한다.
  - 함수에서 새로운 함수가 나오면 잠시후(아래에)에 정의되어 있겠다라고 추측한다.
  - ex)
```Kotlin
fun greet() {
  introduce()
  shakeHands()
}

fun introduce() {
  ~~~
}

fun shakeHands() {
  ~~~
}
```

- +) 개념적으로 생각하자.
  - 가끔 호출하는 곳에서 함수의 인자로 하나(상수)밖에 안 쓰는 경우가 있다.
  - ex)
```kotlin
fun greet() {
  introduceMyName(myName = "희직")
}
fun introduce(myName: String) {
  println(myName)
}
```
위와 같을 때,

```kotlin
fun greet() {
  introduceMyName()
}
fun introduce(myName: String = "희직") {
  println(myName)
}
```
이렇게 하고 싶을 떄가 있다.
그런데, 희직이란 내 이름이 어디서 알아야 하는 지를 생각해보자. 
- 또, 위와 같이 변경하면 introduce 는 "희직" 에 많이 쏠려있다.
- 또한 넘겨주는 이름이 저차원 함수에 묻히게 된다.


### 들여쓰기 무시하기.
- 떄론 간단한 if 문, while 문, 짧은 함수를 들여쓰기를 무시하고 싶을 떄가 있다.
- 하지만 저자는 그래도 들여쓰기로 범위를 제대로 포현한 코드를 선호한다고 한다.


## 팀 규칙
- 팀에 속한다면, 자신이 선호해야 할 규칙은 팀 규칙이다.
- 좋은 소프트웨어 시스템은 읽기 쉬운 문서로 이뤄진다.
- 한 소스 파일에서 봤던 형식이 다른 소스 파일에도 쓰이리라는 신뢰감을 독자에게 줘야한다.
