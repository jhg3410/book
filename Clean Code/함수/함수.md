## 작게 만들어라!
- 함수는 짧아야한다.
- 중첩구조 최대한 줄이자. 
  - 들여쓰기 수준이 1, 2단을 넘어가지말자.
 - 읽고 이해하기 쉬워진다.

## 한 가지만 해라!
- 함수는 한 가지만 해야한다.
- 한 함수 내부에서 추상화 수준이 동일해야 한다.
- 함수를 더 이상 줄이기(추상화가) 불가하다면 한 가지일을 한다고 할 수 있다.(의미는 같지만 이름만 바뀌는)

### 내려가기 규칙
- 위에서 아래로 이야기처럼
- 한 함수 다음에는 한 단계 낮은 함수가 차례로 위치한다.
- 위 함수에서 추상화 한 함수는 그 아래에 나타내고 ... 결국 마지막 함수는 추상화 수준인 낮은 것이다

### 함수 인수
- 인수는 최대한 작아야한다.
  - 인수가 여러개면 이를 이해하는데 시간이 필요하고 주춤하게 된다.
- 플래그 함수는 추하다.
  - true, false 에 따라 일을 하는 것 자체가 2가지의 일을 하기 때문
  - 함수명만 보고 파악하기가 어렵고 헷갈린다.
- 이항 함수에는 인수에 순서가 헷갈리지 않도록 구성해야한다.
  - ex). `assertEquals(expected, actual)` -> `assertExpectedEqualsActual(expected, actual)`
- 인수가 2 ~ 3개이면 독자전인 클래스 변수로 선언이 가능한 지 생각해보자.
  - ex) `makeCircle(double x, double y, double radius)` -> `makeCircle(Point center, double radius)`
- 단항 함수는 함수 와 인수가 동사/명사 쌍을 이루는 것이 좋다.
- 함수 이름에 인수 이름을 넣는 방식도 괜찮다.

### 부수 효과를 일으키지 마라.
- 함수명과 다른 행동을 내부에 넣지마라.
  - ex) checkPassword 함수 내부에 세션을 초기화하는 내용이 있다던지
- 잘못 사용할 가능성이 비일비재하다.

### 출력 인수는 피하자!
- `appendFooter(s)`
  - s 에 Footer 를 붙이는 걸까? s 를 Footer 로 무언가에 붙이는 걸까? 이해하기 어렵다.
  - 그럼 결국 함수의 선언부까지 확인해야한다.
  - 알고보니 `appendFooter(StringBuffer report) : Unit` 라면 인수를 받아서 인수를 변경하기보단 `report.appendFooter()` 를 사용하는 게 더 좋다.

### 명령과 조회를 분리하라!
- ex) `set(attribute: String, value: String)` 이 attribute 를 찾고, value 로 설정하면 true 를 반환하는 함수라면
- `if (set("username", "unclebob"))` 으로 사용되는 데, 이를 함수 내부를 보지않고 의미를 알기는 어렵다.
- 그렇기에. 
```kotllin
if (attributeExists("username")) {
    setAttribute("username", "unclebob")
}
```
으로 분리하자.


### 오류 코드보단 예외를 사용하자
- 여러 조건문으로 오류일 때, 아닐 때를 분리해서 작업을 하면 중첩구조가 너무 심해지고 더러워진다.
- 그렇게 하기보단 예외 처리를 해서, 묶어버리자. try 내부에 작업을 넣고, 예외가 나오면 catch 로!
- 그럴 때, 작업은 오류가 아닌 예외를 던져야겠지~?

---
#### 함수 작성 시엔 처음엔 초안으로 서투르게 작성하고 차근차근 다듬자.
#### 시스템을 구현할 프로그램이 아닌 풀어갈 이야기로 여기자.
