## 성능을 검증

```kotlin
@Test(timeout = 1000)
fun shouldRunUnder10Seconds() {
    val threads = createThreads()
    startAllThreads(threads)
    waitForAllThreadsToFinish(threads)
}
```
- 위와 같은 코드는 단일 스레드에서 환경을 끌어올릴 방법은 거의 없다.

실패했다면 어디서 시간을 보낼까?

1. I/O
   - 소켓 사용, 데이터베이스 연결, 가상 메모리 스와핑 기다리기
   - I/O 연산에서 시간을 많이 보낸다면, 동시성이 성능을 높여주기도 한다.
   - 시스템 한쪽이 I/O 를 기다리는 동안 다른 쪽이 처리해주도록 할 수 있기에
2. 프로세서
   - 수치 계산, 정규표현식 처리, 가비지 컬렉션
   - 프로세서 연산에 시간을 많이 보낸다면, 새로운 하드웨어를 추가해 성능을 높여야 한다.
   - 스레드를 늘린다고 빨라지진 않는데, CPU 사이클은 한계가 존재하기에.

## 다중 스레드에서 발생 가능한 경우

```kotlin
class Example {
    val lastId: Int
    
    fun resetId() {
        lastId = 0
    }
   
   fun getNextId() {
       return ++lastId
   }
}
```    

`restId()` 는 원자적이다.

3번의 명령으로 나뉘는데,
1. ALOAD 0 
   - 0 번째 변수를 피연산자 스택에 넣는다.
   - 0 번쨰 변수는 Example 인스턴스 (`this`)
2. ICONST_0
   - 피연산자 스택에 상수 값 0 을 넣는다.
3. PUTFIELD lastId 
   - 스택의 첫째 값(0) 을 스택의 둘째 값(this)이 가라키는 객체의 lastId 필드에 저장

각 명령 사이에 다른 스레드가 끼어든다 하더라도 결과값은 항상 동일하다.


하지만 `getNextId()` 함수에 스레드가 끼어들면 결과값은 바뀐다.
8번의 명령으로 나뉘는데,

1. ALOAD 0 
   - this 를 피연산자 스택에 넣는다.
   - > 피연산자 스택: this

2. DUP
   - this 를 복사한다.
   - > 피연산자 스택: this, this
     
3. GETFIELD lastId
   - lastId 필드에서 값을 가져와서 스택에 넣는다.
   - > 피연산자 스택: this, 42
     
4. ICONST_1
   - 스택에 정수 상수 1을 넣는다.
   - > 피연산자 스택: this, 42, 1
   
5. IADD
   - 스택 첫째 값(1)을 스택 둘째 값(42)과 더하고 해당 결과(43)를 스택에 넣는다.
   - > 피연산자 스택: this, 43
     
6. DUP_X1
   - 43을 복사해서 this 아래 넣는다.
   - > 피연산자 스택: 43, this, 43
     
7. PUTFIELD lastId 
   - 스택 첫째 값(43)을 스택 둘째 값(this)이 가르키는 현재 객체의 lastId 필드에 넣는다.
   - > 피연산자 스택: 43
     
8. IRETURN
   - 스택 첫째 값이자 유일한 값(43)을 반환한다.
   - > 피연산자 스택: <비어있음>
     

위 명령과정에서 첫번째 스레드가 **GETFIELD lastId** 까지 실행한 후 중단되었고,  
둘째 스레드가 끼어들어 모든 명령을 실행했다고 가정하자.  
둘째 스레드는 43을 반환받았고, 
첫째 스레드가 중단했던 실행을 재개하면 첫째 스레드도 43을 반환받는다.

결국 `getNextId()` 가 두번 실행되었는데 lastId 는 44 가 아닌 43 이 되었다.

- `getNextId()` 를 synchronized 로 선언하면 문제는 해결된다.

## CAS 연산(non blocking)

```kotlin
@Synchronized
fun incrementValue() {
   ++value
}
```

```kotlin

val value = AtomicInteger(0)

fun incrementValue() {
    value.incrementAndGet()
}
```

위의 코드가 Synchronized 보다 거의 항상 더 빠르다. **CAS** 라는 연산인데,  

- `synchronized` 는 **rock** 을 건다. 다른 스레드가 같은 값을 갱신하지 않더라도 무조건 락부터 건다.
- **CAS 연산**은 문제(같은 값을 수정하는)가 없는지를 계속 감시(시도)한다.
  - 항상 락을 거는 게 아닌 문제를 감지해서 문제가 없으면 수행하고 있으면 계속 시도하는 형태

## 데드락

- 서로가 서로(스레드)를 기다리는 상황
- 이도 저도 못하는 상황

### 조건
1. 상호 배제
   > 한 자원을 공유하지만, 해당 자원을 여러 스레드가 동시에 사용 X, 자원의 수가 제한적
   - 조건 깨기
     - 동시에 사용해도 괜찮은 자원 사용.(ex. `AtomicInteger`)
     - 스레드 수 이상으로 자원 수 늘리기
     - 점유하기 전에 필요한 모든 자원이 있는지 확인
       - 한 스레드가 사용할 자원들을 모두 한 번에 확인.
    

2. 잠금 & 대기
   > 스레드가 자원을 점유하면 필요한 나머지 자원까지 모두 점유해서 작업을 마칠 때까지 내놓지 않는다.
   - 조건 깨기
     - 모두 한 번에 점유하지 못하면 지금까지 점유한 자원을 모두 내놓고 처음부터 다시 시작
     - 기악, 라이브락 문제가 생길 수 있지만, 아무런 대척이 없는 경우보단 좋다.

3. 선점 불가
   > 한 스레드가 다른 스레드로부터 자원을 빼앗지 못한다.
   - 조건 깨기
     - 필요한 자원이 잠겻다면, 자원을 소유한 스레드에게 풀어달라 요청
     - 소유한 스레드가 다른 자원을 기다리는 중이였다면, 자원을 모두 풀어주고 처음부터 다시 시작

4. 순환 대기
   > T1, T2 라는 두 스레드, R1, R2 라는 두 자원일 때  
   > T1 가 R1 을 점유, T2 가 R2 를 점유, T1 은 R2 를 필요, T2 는 R1 을 필요(죽음의 포옹)
   - 조건 깨기
     - 같은 순서로 할당 -> 모든 스레드가 지정한 일정 순서로만 동작
       - 단점.
         - 자원을 할당해도 아주 나중에야 사용할지도 모른다.
         - 스레드가 원하는 순서대로 자원을 할당하기 어렵다.
           - ex). 첫 자원을 사용한 후에 둘째 자원을 얻어야 한다면 그렇게 해주기 어렵다.