## 동시성이 왜 필요한가

> 기존엔 동시성은 무조건적으로 성능 개선을 위함으로 인지하고 있었다.

### 결합을 없애는 전략

- 무엇과 언제를 분리한다.
    - 여기서 **언제**가 동시성 코드이고, **무엇**이 동시성으로 돌리려는 코드가 아닐까 생각.
- 스레드가 하나라면 무엇과 언제가 밀접하다.

### 구조적 이점

- 무엇과 언제를 분리하면, 성능(효율) 뿐만 아니라 애플리케이션의 구조도 극적으로 나아진다.
    - 구조적인 관전에서 프로그램이 작은 협력 프로그램의 여럿으로 보인다.
- ex). 웹 요청이 들어오면 웹 서버는 비동식으로 서블릿을 실행.
    - 각 서블릿 스레드는 다른 서블릿 스레드와 무관해진다. -> 구조적으로도 깔끔

### 성능적 이점

- 구조적 개선뿐 아니라 성능을 위해서라도 동시성은 불가피하다.
- ex). 수강신청을 할 때 한명씩 처리를 한다면 대기인원에 따라 대시시간이 비약적으로 상승한다.
    - 그렇기에 동시성을 이용해 한 번에 여러명을 처리해야 한다.

## 난관

```kotlin
class Example {
    val number = 42

    fun getPlusNumber() = ++number
}
```

위와 같은 클래스가 있을 때 두 개의 스레드가 같은 인스턴스를 공유하면서,
`getPlusNumber` 함수를 호출하면 어떻게 될까?

1. 43, 44
2. 44, 43
3. 43, 43

3 개 중 모두가 올 수도 있다. 확실하지 않다는 건데,
두 스레드 중 우선순위가 정해져 있지 않고, 같은 인스턴스를 동시에 참조하기 때문이다.
결국 3 번의 결과도 초래할 수도 있다.

## 동시성 방어 원칙

### 단일 책임 원칙

- 동시성 코드는 독자적인 개발, 변경, 조율 주기가 존재한다.
- 동시성 코드는 다른 코드와 분리해야한다.

### 자료 범위를 제한.

- 공유 자료를 최소한으로 해야한다.
- 앞선 난관을 해결하기 위해 일반적으로 임계영역을 `synchronized` 로 보호하는 방식을 사용하는데 이러한 임계영역의 수가 많을수록 우리는 힘들다.

### 자료 사본을 사용.

- 애초에 공유를 하지를 말자.
- 공유하려는 자원을 `copy()`(복사) 해서 사용하여 공유 객체 사용을 피해자.

### 스레드는 가능한 독립적으로

- 위와 일맥상통한다.
- 공유자원을 사용하지 않고, 매개변수를 받던, 복사를 하던 로컬변수를 사용해, 자신만의 독자적인 시스템에서 동작하도록 하자.

### 실행 모델

1. 생산자 - 소비자
   - 생산자 스레드가 생산하면 소비자 스레드가 소비하는 형태
   - 각자 생산했다, 소비했다는 시그널을 보내 서로의 상태를 확인한다.
   - 하지만 시그널이 어긋나면 서로의 시그널을 기다릴 가능성이 존재.

2. 읽기 - 쓰기
   - 읽기 스레드는 공유 자원을 사용, 쓰기 스레드는 공유 자원을 갱신
   - 읽기 스레드만 계속해서 진행되면 **처리율 증가**, 하지만 기아 현상 발생가능
   - 쓰기 스레드가 우선순위가 높다면, 읽기 스레드가 버퍼를 기다리느라 **처리율 감소**

3. 식사하는 철학자들
   - 스레드들이 서로 원하는 양의 자원을 확보하지 못해 계속 대기하는 상태를 설명

### 올바른 종료 코드는 구현이 어렵다.

- 각 스레드가 절대 오지 않을 시그널을 기다리는 상태가 올 수 있다.
- 위와 같은 실행모델에서도 흔히 발생할 수 있기에
- 개발 초기부터 종료 코드를 고민하고 동작하도록 만들자.

### 스레드 코드 테스트

- 스레드가 둘 이상이라면 테스트가 급격하게 복잡해진다.

**고려사항**
- 시스템 실패를 '일회성'이라 치부하지 말자.(언제든 다시 일어날 수 있다.)
- 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌아가도록 만들자.
- 다중 스레드를 쓰는 코드를 다양한 환경에 쉽게 끼워 넣을 수 있도록 구현
- 프로세서 수보다 많은 스레드를 돌려보자.
- 다른 플랫폼(OS) 에서도 돌려보자.
- 보조 코드를 넣어서 강제로 실패를 일으키도록 해보자.


**보조 코드를 넣어서 강제로 실패를 일으키도록 해보자.**
- 일부로 코드 중간에 보조 코드를 넣자.
  - ex). `wait()`, `sleep()`, `yield()`, `priority()`
  - 보조 코드를 추가할 위치를 더욱 확실하기 위해, 스레드를 제어하는 코드와 스레드를 모르는 코드를 분리하자.

ex).
```kotlin
interface ThreadJigglePoint {
    fun jiggle()
}
```

- 위 `jiggle()` 함수를 테스트환경에선 `slee()`이나 `yield()` 를 무작위로 호출하고, 떄론 아무 동작도 하지 않게 만든다.
- 배포 환경에선 비워놓으면 된다.
