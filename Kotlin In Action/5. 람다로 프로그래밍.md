# 5장. 람다로 프로그래밍

<aside>
💡 **람다 식, 람다**는 기본적으로 다른 함수에 넘길 수 있는 작은 코드 조각을 뜻한다.

</aside>

### 지피티에게 물어보자 람다식, 람다식이란?

**람다식**은 익명 함수의 한 형태로, 이름이 없는 함수를 뜻합니다.

람다식은 코드 블록을 데이터로 취급할 수 있게 해주며, 다른 함수의 인자로 전달되거나 변수에 저장될 수 있습니다.

람다식은 주로 간결하고 일회성으로 사용되는 간단한 함수 정의에 유용합니다.

책에 좋은 의미가 있다.

일련의 동작을 변수에 저장하거나, 다른 함수에 넘겨야 하는 경우 익명 내부 클래스를 사용해 왔지만, 이젠 람다로 이것을 대체할 수 있다!!

그러니깐

“일련의 동작을 변수에 저장하거나, 다른 함수에 넘겨야 하는 경우 “

이럴 때 사용하는 게 람다.

함수를 값처럼 취급한다는 의미이다.

### 람다 대신 멤버 참조

```kotlin
val people = listOf(Person("Alice", 23), Person("Heejik", 26))

println(people.maxBy { it.age })   // 람다

println(people.maxBy(Person::age)) // 멤버 참조
```

함수나 프로퍼티를 반환하는 역할을 수행하는 람다는 멤버 참조로 대치가 가능핟.

### 람다 식의 문법

```kotlin
 { x: Int, y: Int -> x + y }
```

이게 람다 식이다.

여기저기 전달할 수 있는 동작의 모음.

함수에 인자로 넘기면서 정의하기도, 변수에 저장하기도 가능하다.

값으로 취급하니깐

```kotlin
val sum = { x: Int, y: Int -> x + y }
```

```kotlin
{ println(42) }()    // 1

run { println(42}    // 2
```

1 처럼 람다식을 선언과 동시에 직접 호출(`()`) 이 가능하다.

하지만 굳이? 읽기도 어렵고 쓸모도 없다.

하지만 이렇게 쓸 일이 있다면 2번 처럼 `run` 을 사용하면 가독성이 더 좋다.

코틀린에서 함수 호출에 람다식을 파라미터로 사용하면

괄호 외부에 중괄호로 바로 선언할 수 있다.

이것은 마지막 파라미터가 람다형태로 받을 때만 가능하다.

만약 2개 이상의 파라미터가 람다로 받는다면 이 땐 괄호내에 선언하는 게 더 보기가 좋다.

(누구는 괄호에, 누구는 외부에 차별하지말자.)

람다 식의 파라미터가 하나뿐이고 타입을 컴파일러가 추론이 가능할 때 `it` 으로 바로 해당 파라미터를 사용할 수 있다.

하지만 너무 남발하지 말자.

특히 람다가 중첩되면 `it` 이 어디 람다의 파라미터인지 파악하기 어렵다.

람다를 변수에 저장할 땐 파라미터 타입을 추론할 문맥이 존재하지 않는다. 따라서 무조건 명시(우리가 함수를 정의할 때도 파라미터에 타입은 무조건 명시하는 느낌)

```kotlin
val getAge = { p: Person -> p.age }
people.maxBy(getAge)
```

람다식의 본문이 여러 줄로 이뤄질 때 람다식의 결과는 본문의 맨 마지막에 있는 식

### 람다의 비용

실행(런타임) 시점에 코틀린 람다 호출에는 아무 부가 비용이 들지 않는다.

프로그램의 기본 구성 요소와 비슷한 성능을 가진다.

8장에 추가로 이유가 나온다고 하니 그때 자세히 알아보자.

### 멤버 참조(`::`)

개발하면서 종종 많이 사용해왔다.

`viewModel::getInfo`

요렇게,,

어떨 때 사용하냐면 함수의 인자로 함수를 넘길때(고차함수)에서 람다 대신 사용해왔다.

`{ viewModel.getInfo() }` →  `viewModel::getInfo`

이렇게 대신할 수 있다.

**그럼 이게 왜 좋은가?**

일단 넘기려는 코드가 함수인데, 그걸 또 람다로 감싸면?

중복되는 느낌이 있다.

람다도 함수이고 람다 내부도 함수이다. 기분이 좋지않다.

하지만 멤버 참조는 매우 깔끔하다.

그리고 람다 내부의 함수에 인자가 여러개라면? 그리고 딱히 변환없이 그냥 위임하는 경우라면?

아래 코드처럼.. 인자가 늘어나면 계속 추가해야한다. 수동적으로

```kotlin
navigateToLedgerDetail = { navOptions, ledgerId, isStaff ->
    homeNavController.navigateLedgerDetail(navOptions, ledgerId, isStaff)
}
```

그런데 멤버 참조를 쓰면

```kotlin
navigateToLedgerDetail = homeNavController::navigateLedgerDetail
```

굳.  알아서 인자가 잘 들어간다.

또 하나 멤버 참조로 변수를 선언할 수 있다.(이건 몰랐다..)

```kotlin
val getAge = Person::age
```

이게 된다. 그럼 이건 함수이다 타입은? `() → Int`

이렇게 변수에 할당한다는 건 결국 멤버 참조는 값을 생성한다는 의미이다.

난 기존엔 멤버 참조 메서드에 직접 접근해서 사용하는 줄 알았다.

값을 만드는 줄은 몰랐다.

그럼? 람다랑 다를 게 뭐야?

가독성말고 좋은 게 없잖아.(그걸로도 이미 쓸 이유지만)

`compose` 에서 `recomposition` 에서 차이를 경험한 적이 있다.

람다를 쓸 때보다 멤버 참조를 쓸 때 `recomposition` 이 적게 일어났다.

그래서 멤버 참조는 값을 새로 생성한다고 생각하지 않았다.(값이란 개념을 생각하지 않았다. 근데 생각해보면 함수의 인자로 들어갈 수 있는데 값이라고 유추했어야 하지 않나..?)

그럼 무슨 차이가 있길래? recomposition 에서 차이를 보였을까?

아래 코드를 실행해보자.

```kotlin
fun printJik() {
    println("JIK")
}

fun main() {
    val member1 = ::printJik
    val lambda1 = { printJik() }
    val member2 = ::printJik
    val lambda2 = { printJik() }

    println("member1.hashcode = ${member1.hashCode()}")
    println("lambda1.hashcode = ${lambda1.hashCode()}")
    println("member2.hashcode = ${member2.hashCode()}")
    println("lambda2.hashcode = ${lambda2.hashCode()}")
}
```

```kotlin
a.hashcode = 824655241
b.hashcode = 500977346
c.hashcode = 824655241
d.hashcode = 20132171
```

보면은 멤버 참조로 할당된 변수의 hashcode 값은 항상 동일했다.

하지만 람다는 보다시피 hashcode 값이 다르다.

이는 결국 멤버 참조는 계속 새로운 값을 생성 하는 게 아닌 단 **하나의** 값만 생성하는 걸 알 수 있다.

그래서 `recomposition` 에서 괜찮았구나…

## 컬렉션 함수형 API

```kotlin
people.filter { it.age == people.maxBy(Person::age)!!.age }
```

여기서 잘못된 게 뭘까?

만약에 `people` 리스트에 원소가 10만명이 있다면?

해당 시간 복잡도는 **10만 * 10만** 이 되어버린다.

그래서 람다 내부에 또 람다를 넘기면 겉으론 단순해보여도, 내부적으론 매우 복잡한 계산식이 될 때가 있다.

그러니 아래처럼 사용하자.

```kotlin
val maxAge = people.maxBy(Person::age)!!.age
people.filter { it.age == maxAge }
```