# 3장 함수 정의와 호출

## 디폴트 파라미터 값

> 자바에는 디폴트 파라미터 값이란 개념이 없기에,  코틀린 함수를 자바에서 호출할 땐 디폴트 파라미터 값에 제공되어도 모든 인자를 명시해야 한다.
>

하지만, 편하게 호출하고 싶으면 **@JvmOverloads** 어노테이션을 사용하면 된다.

해당 어노테이션을 추가하면, 코틀린 컴파일러가 자동으로 맨 마지막 파라미터로부터 **파라미터를 하나씩 생략한 오버로딩한 자바 메서드를 추가**해준다.

여기서 오버로딩한 함수들의 생략된 파라미터들은 코틀린 함수의 **디폴트 파라미터 값을 사용한**다.

## 최상위 함수

> java 에선 모든 메서드는 클래스 내부에 존재해야 한다.
>

하지만 이것이 때론 무의미한 메서드 집합의 클래스를 만들어낼 수 있다.

→ Kotlin 에선 함수를 최상위에 선언할 수 있다.

```kotlin
fun joinToString(...): String {
	// ...
}
```

JVM 은 클래스 안에 들어있는 메서드만을 실행할 수 있는데 이처럼 선언하면 어떻게 실행될 수 있을까?

→ 코틀린 컴파일러가 해당 파일을 컴파일 할 때 자동으로 새로운 클래스를 정의해준다.

어떻게 정의될까?

```java
public class JoinKt {
	public static String joinToString(...) {
		// ...
	}
}
```

이처럼 최상위 함수가 존재하는 파일명이 클래스의 이름이 된다.

그리고 이 함수들은 해당 클래스의 정적인 메서드가 된다.

따라서 java 에선 `JoinKt.joinToString()` 으로 호출하면 된다.

JoinKt 처럼 파일명으로 사용하고 싶지 않다면? → 파일 맨 앞에 `@JvmName` 어노테이션을 사용하면 된다.

```kotlin
@file:JvmName("StringFuctions")

package strings

fun joinToString(..): String {
	// ...
}
```

→ 그럼 자바에서 `StringFunctions.joinToString(…)` 이처럼 사용할 수 있다.

## 최상위 프로퍼티

```kotlin
val UNIX_LINE_SEPARATOR = "\n"
```

이처럼 최상위 프로퍼티를 생성하면 컴파일 과정에서 게터, 세터가 생성된다.

이는 상수처럼 보이지만 자연스럽지 못하다.

→ `const` 키워드를 붙이면 컴파일 할 때 `public static final` 필드로 컴파일 된다

```kotlin
const val UNIX_LINE_SEPARATOR = "\n"
```

```java
public static final String UNIX_LINE_SEPARATOR = "\n";
```

## 확장 함수

> 자바 API 를 재작성하지 않고 코틀린이 제공하는 여러 편리한 기능을 사용할 수 있게 해준다.
>

→ 이미 내장된 클래스에 함수를 추가할 수 있게 해준다는 의미

<aside>
💡 어떤 클래스의 멤버 메서드인 것처럼 호출. 하지만 그 클래스 밖에 선언된 함수

</aside>

```kotlin
fun String.lastChar(): Char = this.get(this.length - 1)
```

여기서 `String` 은 수신 객체 타입.

여기서 `this` 는 수신 객체.

자바 클래스로 컴파일된 클래스는 모두 확장함수 추가 가능

### 캡슐화 문제

> 확장 함수 내부에서도 수신 객체의 메서드나 프로퍼티 사용 가능
>

하지만 확장 함수 내부에선 수신 객체의 `private` 함수, `protected` 함수는 사용할 수 없다.

그래서 캡슐화를 깨진 않는다.