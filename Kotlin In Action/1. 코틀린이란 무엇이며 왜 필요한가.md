# 1장. 코틀린이란 무엇이며, 왜 필요한가?

**코틀린의 주목적**
현재 자바가 사용되고 있는 모든 용도에 적합하면서도 더 간결하고 생산적이며 안전한 대체 언어를 제공

**코틀린은 정적 타입 지정 언어**

구성 요소의 타입을 컴파일 시점에 알 수 있고, 객체의 필드나 메서드를 사용할 때마다 컴파일러가 타입을 검증

**정적타입 지정 언어**
유지 보수, 신뢰, 성능(런타임에서 메서드를 찾을 필요가 없으니) 에서 장점
**동적타입 지정 언어**
코드가 더 짧고, 데이터 구조를 더 유연하게 생성 및 사용의 장점

대부분의 코틀린 표준 라이브러리 함수는 **인자로 받은 람다 함수를 inlining** 한다.
→ 람다를 사용해도 새로운 객체가 만들어지지 않는다 → GC 의 일이 줄어들어 프로그램 안정성이 올라간다.

ex). Kotlin.Result 의 내부 함수들 대부분이 inline 함수

코틀린은 젯브레인에서 개발

젯브레인 → IDE 개발

코틀린이란 언어의 특성을 애초에 인텔리J IDE 에 맞춰서 설계 및 개발

→ IDE 와의 호환이 매우 좋다

언어가 간결하다

→ 해당 언어로 작성된 코드를 읽을 때 **의도를 쉽게 파악할 수 있는 구문 구조**를 제공하고,
그 의도를 달성하는 방법을 **이해할 때, 방해가 될 수 있는 부가적인 준비 코드가 적다**

→ 자바에 존재하는 게터, 세터, 생성자 파라미터를 필드에 대입하기 위한 로직 등 
의미가 없는 부가적인 요소를 줄이기 위해 모두 제거

코틀린은 언어가 제공하지 않는 연산자를 개발자가 정의할 수 있게 허용 X
→ 이미 존재하는 연산자만 `operator fun`  허용.

→ 코드가 암호문 처럼 보일 수 있고, 기호보단 단어로 이뤄진 이름이 검색 및 읽기 좋다.

프로그래밍 언어가 안전하다

→ **프로그램이 발생할 수 있는 오류**를 **언어에서 원천적으로 방지**해준다는 뜻

→ 개발자가 컴파일러에게 프로그램의 동작 정보를 제공해야만 검증 절차를 통해 안전해질 수 있다.

→ **생산성과 안정성 사이에 트레이드 오프가 관계가 존재한다.**

코틀린은 “안전”을 위해 아래와 같이 존재한다.

1. 타입 추론
    - 타입 추론으로 인해 정적 지정 타입 언어라도 더 간결하고 빠르게 개발이 가능
2. nullable 
    - null 이 될 수 있는 값에 nullable 타입을 붙여 컴파일 단에서 널이 될 수 있는, 없는 값을 구분한다.
    - NullPointerException 을 방지한다.
    - 프로그램이 런타임에 급작스레 중단되는 것을 방지
3. ClassCasetException
    - 자바에선 타입 검사와 캐스트를 따로 처리해
    - 일부 개발자는 검사를 하지않고 캐스트만 처리하는 경우도 있다.
    - 하지만 코틀린에서는 타입 검사와 캐스트가 한 번에 이뤄져 더욱 안전하다.