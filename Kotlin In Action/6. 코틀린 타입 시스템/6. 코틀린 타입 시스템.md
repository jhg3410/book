# 6장. 코틀린 타입 시스템

# 널 가능성

> 이 부분에선 자바와 kotlin 에서의 null 을 다루는 방식의 차이 및 코틀린만의 Null 을 더 잘 다루는 방법들을 보여준다.
> 하지만 이미 알고 있는 부분은 제외한다.

## !! (not-null assertion)

> 널이 아님을 단언한다.

근본적으로 `!!` 는 컴파일러에게 “나는 이 값이 `null` 이 아님을 잘 알고 있다. 내가 잘못 생각했다면 예외가 발생해도 감수하겠다” 라고 말하는 것

`!!` 가 약간 무례해 보인다.

마치 컴파일러에게 소리를 지르는 느낌을 준다.

→ 이건 사실 의도한 것이다.

→ 코틀린 설계자들은 컴파일러가 검증할 수 없는 단언을 사용하기보단 더 나은 방법을 찾아보라는 의도를 넌지시 표현하려고 `!!` 라는 못생긴 기호를 택했다

그럼 왜 있을까?

→ 때론 유용할 때가 있다.

예를 들어

```kotlin
 var name: String? = "Hee"

fun a() = name != null

fun b() {
    print(name.length) // Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type String?
}

fun c() {
    a()
    b()
}
```

`a` 라는 함수 다음에 `b` 함수가 나올게 명시되어 있다. 이는 확실하다.

하지만? 컴파일러는 그런 연관 관계를 알지 못한다.

→ 그래서 `b` 함수에서 name 변수는 nullable 이다.

그럼 b 에서 `null check` 를 또 해야한다.

그러고 싶진 않다. 이미 null 이 아님을 확신할 수 있다.

그럴때 `!!` 쓰면 되는 것

그래도  `!!` 쓰고 싶지 않다면 아래처럼 하면 된다.

중복이긴 하지만, 나중에 `a` 함수가 변경될 수 있으니, 이렇게 안전 장치를 걸어두는 것도 좋은 방법이다.

```kotlin
// 1
fun b() {
	print(name!!.length)
}

// 2
fun b() {
	print(name?.length ?: return)
}
```

`!!`  로 `NPE` 가 일어나도 어떤 객체(프로퍼티)에서 예외가 발생한 지는 스택 트레이스에서 알려주지 않는다.

단순히 해당 `!!` 이 발생된 줄을 알려준다.

그래서 아래와 같이 한 줄에 함께 쓰는 일을 하지말자.

```kotlin
person.company!!.address!!.country
```


## 나중에 초기화할 프로퍼티

> 때론 `null` 이 될 필요가 없는 프로퍼티이지만, 초기화를 피하기 위해 `null` 로 선언하는 경우가 있다.

```kotlin
class MyService {
    fun performAction(): String = "foo"
}

class MyTest {
    private var myService: MyService? = null
    @Before
    fun setUp() {
        myService = MyService()
    }

    @Test
    fun testAction() {
        Assert.assertEquals("foo", myService!!.performAction())
    }
}
```

위는 테스트 코드 예시이다.

예처럼 `Before`에서 초기화를 진행하고 싶지만,  `Before` 에서 myService 를 선언하면 testAction 에서 이를 사용할 수 없다.

그렇기에 위처럼 어쩔 수 없이(`null` 일 필요가 없지만) null 로 선언하게 된다.

→ 그러면 `myService` 를 사용할 때 마다 널 체크나 !! 를 사용해야 한다.

```kotlin
class MyService {
    fun performAction(): String = "foo"
}

class MyTest {
		private lateinit var myService: MyService
    @Before
    fun setUp() {
        myService = MyService()
    }

    @Test
    fun testAction() {
        Assert.assertEquals("foo", myService.performAction())
    }
}
```

이렇게 `lateinit` 를 쓰면 된다.

→ `lateinit` 을 알고는 있었지만, 코드짤 땐 잘 쓰지를 않았다. 분명 위와 같은 경우도 있었던 것 같은데 염두에 두고 있지 않아서 인 듯하다.

## 타입 파라미터의 널 가능성

> 타입 파라미터는 nullable 한 타입도 추론이 가능하다

```kotlin
fun <T> printHashCode(t: T) {
	println(t?.hashCode())
}

>>> printHashCode(null)
null
```

위처럼 하면 T 는 `Any?` 로 추론된다.

하지만 `T` 를 `non null` 로 보장받고 싶다면?

```kotlin
fun <T: Any> printHashCode(t: T) {
	println(t.hashCode())
}

>>> printHashCode(null)
compile error: Null can not be a value of a non-null type TypeVariable(T)
```

이 처럼 타입 상한을 `non-null` 로 지정하면 된다.

## 널 가능성과 자바

> 자바와 코틀린를 함께 사용할 때 널처리를 어떻게 할지 알아보자

자바는 `nullable` 지원 X

코틀린은 `nullable` 지원 O

### Annotation

자바에선 코드에 `non-null` 과 `nullable` 을 각각 나타내는 annotation 이 존재한다.

- `@Nullable`
- `@NotNull`

코틀린은 해당 annotation 을 인식하고 이해해서 널 가능성을 체크할 수 있다.

### 플랫폼 타입

> annotation 이 없는 경우엔 자바의 타입은 코틀린의 **플랫폼 타입**이 된다.

플랫폼 타입이란 코틀린이 널 관련 정보를 알 수 없는 타입을 말한다.

→ 자바

자바에서 타입이 `null` 인지, 아닌지 코틀린 컴파일러는 알 수 없다.

→ 그렇기에 널 처리에 대한 책임은 개발자에게 있다.

→ 잘못 사용했다면 `NPE` 가 발생한다

![자바와 코틀린 타입간의 null 처리](resource/Untitled.png)

자바와 코틀린 타입간의 null 처리

예시를 보자.

```java
// 자바
public class Person {
    private final String name;

    public Person(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
```

위와 같은 자바로 작성된 클래스가 있고,

```kotlin
// 코틀린
fun yellAt(person: Person) {
    println(person.name.uppercase() + "!!!")
}

fun main() {
    yellAt(Person(null))
}
```

아래처럼 코틀린으로 위 Person 을 사용해보자

위 main 함수를 실행하면

> NullPointerException: [person.name](http://person.name/) must not be null

해당 런타임 에러가 발생한다

왜냐면 `uppercase` 함수는 다음처럼 `String` 타입의 확장함수이다.

![Untitled](resource/Untitled1.png)

하지만 위 코드에선 [person.name](http://person.name) 의 값이 `null` 이라서 위 에러가 발생.

이처럼 코틀린 컴파일러는 자바 코드의 널 가능성을 알지 못한다.

위처럼 코틀린에선 `non-null` 을 가정하고 코드를 짜지만 자바에선 `null` 을 반환할 수도 있다.

따라서, 자바 코드에서 널 가능성을 항상 염두에 두고, 확인한 뒤에 널 가능성이 있다면 아래처럼 널 체크를 해야한다.

```kotlin
// 코틀린
fun yellAt(person: Person) {
    println((person.name ?: "AnyOne").uppercase() + "!!!")
}
```

자바 API 를 다룰 땐 대부분의 라이브러리들이 널 관련 `annotation` 을 쓰지 않기에, 내부 코드나 문서를 확인한 뒤, 널 가능성을 살펴봐야한다.

(annotation 을 쓰지 않는다고, `non-null` 을 의미하는 게 아니다.)

### 그럼 왜 코틀린은 플랫폼 타입을 도입했을까?

> 모든 자바 타입을 `nullable` 로 다루면 되지 않을까?

물론 가능하고, 더 안전해진다.

하지만, 널이 될 수 없는 값에도 널 체크가 강제된다.

만약 모두 nullable 로 다룬다면

→ 제네릭을 다룰 때 상황은 더 나빠지는데, 자바의 `ArrayList<String>` 을 코틀린에선 `ArrayList<String?>?` 으로 다룰 것이다. 그러면 해당 배열과 내부 원소에 접근할 때마다 `null check` 가 강제된다.

널 안전성으로 얻는 이익보다, 검사에 드는 비용이 훨씬 커진다. → 모든 타입의 값에 항상 널 검사를 작성하는 건 너무 성가신 일이다.

<aside> 💡 그래서 코틀린 설계자들은 자바의 타입을 가져온 경우, 프로그래머에게 그 타입을 처리할 책임을 부여하는 실용적인 접근 방법을 선택.

</aside>