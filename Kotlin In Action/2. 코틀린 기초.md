## 함수

코틀린에서 if 는 식이다.

식 vs 문

식은 값을 만들어내며 계산에 참여한다.

문은 아무런 값을 만들어내지 않는다.

코틀린에선 **루프를 제외한 대부분의 제어 구조가 식**

코틀린 함수에서

블록이 본문인 함수

```kotlin
fun max(a: Int, b: Int): Int {
    return if (a > b) a else b
}
```

식이 본문인 함수

```kotlin
fun max(a: Int, b: Int) = if (a > b) a else b
```

식이 본문인 함수에서는 반환 타입을 제거 해도 되는데

왜 블록이 본문인 함수는 반환 타입을 제거하면 안될까?

→ 블록이 본문인 함수가 길어지면 여러개의 return 이 나올 수 있다.

→ 그럴 때 반환타입을 명시하지 않으면 가독성이 너무 안 좋아진다.

## 변수

왜 코틀린은 자바와 다르게 키워드(`val, var`) 로 변수를 선언할까?

→ 코틀린은 타입 추론을 지원한다.

→ 자바처럼 타입이 변수 선언 맨 앞에 오게 될 떄 타입을 지우게 되면 변수 선언인지, 식인지 구분을 할 수가 없다.

문자열 템플릿

ex).

```kotlin
val name = "Heejik"

println("Hello $name")
```

위에서 “Hello $name” 부분이 문자열 템플릿을 사용하는데

컴파일된 코드는 StringBuilder 를 사용해, 문자열 상수와 변수를 빌더에 추가하는 형태라서 효율적.

## 클래스와 프로퍼티

> 프로퍼티는 클래스 내부 필드(접근자, 속성)
>

Kotlin 에서 클래스가 컴파일되면 자바의 필드, 게터, 세터가 자동으로 생성이 되는데

```kotlin
val person = Person(name = "Heejik", age = 26)
```

자동으로 생성되는 `getter` 는 보통 `getName()` 처럼 get 이 붙고 `setter`는 set 이 붙는다.

속성의 이름이 isMarried 같이 `is` 로 시작한다면 getterr 함수명은 get 이 붙지 않고 동일하게 isMarried() 이다. setter 함수명은 is 가 set 으로 바뀐다.

<aside>
💡 커스텀 getter 는 클라이언트가 프로퍼티에 접근할 때마다 게터가 프로퍼티(커스텀 게터로 선언된 변수) 값을 매번 다시 계산한다.

</aside>

## when

```kotlin
when (setOf(c1,c2)) {
	setOf(RED, YELLOW) -> Orange
}
```

난 기존에  c1인 YELLOW, c2가 Red 인 경우엔 위 setOf(RED, YELLOW) 조건을 안 탈 줄 알았다.

하지만 집합이라 순서는 상관없다. 내부 객체 **집합**만 동일하면 조건을 탄다.

## 스마트 캐스트

```kotlin
val color: Color = COLOR.YELLOW 
if (color is COLOR.YELLOW) {
	// 해당 블록 내부에선 이미 color 는 COLOR.YELLO 로 스마트 캐스팅 됨 
	// ~~~
}
```

코틀린에서는 is 로 타입을 검사하면서 캐스팅까지 같이 해준다.

```kotlin
var color: Color = COLOR.YELLOW 
if (color is COLOR.YELLOW) {
	// color 의 타입은 COLOR 이다 (스마트 캐스팅 X) 
	// ~~~
}
```

하지만 위처럼 변수가 `var` 이거나, 커스텀 접근자를 사용한 변수라면 스마트 캐스팅이 불가능하다.

확실한 수 없다. 위 `if` 에서 타입을 검사해도 내부 블록에서 바뀔 줄 누가 아나(멀티 스레드 환경에서 변경할 수도 있다.)